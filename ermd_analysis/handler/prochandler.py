#!/usr/bin/env python

from ermd_analysis.utils import *
from ermd_analysis.event import *
from ermd_analysis.process import Process
from ermd_analysis.handler import EventHandler
from loguru import logger

class ProcHandler(EventHandler):
    def __init__(self):
        pass

    def handle(self, fields, tree):
        action = fields[0]

        if action == 'image-loaded':
            self.handle_loadimage(fields, tree)

        if action == 'True-ProcessCreated':
            self.handle_createprocess(fields, tree)
            
        if action == 'Process-Terminated':
            self.handle_terminateproc(fields, tree)

        if (action in 
            (
                'Proces-memory-write-accessattempt',
                'Proces-action-memory-write-accessattempt',
                'Proces-suspend-resume-acessattempt',
                'Proces-terminate-attempt',
                'Proce-smeomry-write-delete-access-attempt'
            )
        ):
            self.handle_openprocess(fields, tree)

        else:
            return

    def handle_loadimage(self, fields, tree):
        image_name = fields[1]
        if MNTPATH in image_name:
            image_name = image_name[len(MNTPATH):]

        elif DEVICEPATH in image_name:
            image_name = image_name[len(DEVICEPATH):]
       
        # Ignore loading DLL images from System32 
        if image_name.rsplit('\\')[0] == SYSTEM32:
            return

        target_pid = int(fields[2].split()[-1].strip())
        injector_pid = int(fields[3].split()[-1].strip())
        addr = fields[4]

        # Add processes if not present in tree
        if (target_pid not in tree):
            tree[target_pid] = Process()

        if (injector_pid not in tree):
            tree[injector_pid] = Process()

        # Ignore self injection
        if target_pid == injector_pid:
            return
#            inject_event = Event()
#            inject_event.set_type(PROC_SELFINJ)
#            inject_event.add_arg('source_image', image_name)
#            tree[target_pid].add_event(inject_event)

        # If injecting into other process
        else:
            inject_event = Event()
            inject_event.set_type(PROC_INJ)
            inject_event.add_arg('source_image', image_name)
            inject_event.add_arg('target_pid', target_pid)
            tree[injector_pid].add_event(inject_event)

            injected_event = Event()
            injected_event.set_type(PROC_INJED)
            injected_event.add_arg('source_image', image_name)
            injected_event.add_arg('injector_pid', injector_pid)
            tree[target_pid].add_event(injected_event)

            # Test for malware DLL injection
            if ((image_name in tree[injector_pid].file_create) or
                (image_name is tree[injector_pid].source_image)
            ):
                if target_pid not in tree[injector_pid].get_children():
                    tree[injector_pid].bad_actions[TYPE_INJECTION] += 1

    def handle_createprocess(self, fields, tree):
        pid = int(fields[1])
        ppid = int(fields[2])
        source_image = fields[3]
        if MNTPATH in source_image:
            source_image = source_image[len(MNTPATH):]
        
        # Add processes if not present in tree
        if (pid not in tree):
            tree[pid] = Process(pid=pid, ppid=ppid)

        if (ppid not in tree):
            tree[ppid] = Process(pid=ppid)

        tree[pid].set_sourceimage(source_image)
        create_event = Event()
        create_event.set_type(PROC_CREATE)
        create_event.add_arg('child_pid', pid)
        tree[ppid].add_event(create_event)
        tree[ppid].add_child(pid)

        if TEMP in source_image:
            tree[ppid].bad_actions[TYPE_TMPEXE] += 1

    def handle_terminateproc(self, fields, tree):
        pid = int(fields[1])
        if (pid not in tree):
            tree[pid] = Process(pid=pid)

        term_event = Event()
        term_event.set_type(PROC_TERM)
        tree[pid].add_event(term_event)

    def handle_openprocess(self, fields, tree):
        return
