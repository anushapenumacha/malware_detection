#!/usr/bin/env python

from ermd_analysis.event import *
from ermd_analysis.utils import *
from ermd_analysis.process import Process
from ermd_analysis.handler import EventHandler
from loguru import logger

class ProcHandler(EventHandler):
    def __init__(self):
        pass

    def handle(self, fields, tree):
        action = fields[0]

        if action == 'image-loaded':
            self.handle_loadimage(fields, tree)

        if action == 'True-ProcessCreated':
            self.handle_createprocess(fields, tree)
            
        if action == 'Process-Terminated':
            self.handle_terminateproc(fields, tree)

        if (action in 
            (
                'Proces-memory-write-accessattempt',
                'Proces-action-memory-write-accessattempt',
                'Proces-suspend-resume-acessattempt',
                'Proces-terminate-attempt',
                'Proce-smeomry-write-delete-access-attempt'
            )
        ):
            self.handle_openprocess(fields, tree)

        else:
            return

    def handle_loadimage(self, fields, tree):
        image_name = strip_hdr(fields[1])
        target = int(fields[2].split()[-1])
        injector = int(fields[3].split()[-1])
        addr = fields[4]

        if target == injector:
            return

        if target in tree.processes[injector].children:
            if '\\Windows' in tree.processes[target].source_image:
                logger.debug("Process {injector} attempting to inject into Windows executable"
                    " {tree.processes[target].source_image} with PID {target}")
        
        if ((target not in tree.get_processes()) and 
            (any(system32 not in image_name for system32 in SYSTEM32))
        ):
            logger.debug("Process {injector} attempting to inject into target process {target}")

    def handle_createprocess(self, fields, tree):
        pid = int(fields[1])
        ppid = int(fields[2])
        source_image = strip_hdr(fields[3])
        
        if ppid in tree.get_processes():
            logger.debug(f"Detected process {pid} created by {ppid}!")
            if source_image == tree.processes[ppid].source_image:
                logger.debug(f"Detected in-memory propagation!")
            tree.add_process(pid=pid, ppid=ppid, image=source_image)


    def handle_terminateproc(self, fields, tree):
        pid = int(fields[1])
        return

    def handle_openprocess(self, fields, tree):
        action = fields[0]
        target = int(fields[1])
        actor = int(fields[2])
        
        if actor not in tree.get_processes():
            return

        if target == actor:
            return

        if ((action == 'Proces-memory-write-accessattempt') or
            (action == 'Proces-operation-memory-write-accessattempt')
        ):
            if target not in tree.processes[actor].children:
                logger.debug(f"Process {actor} requesting non-child process {target} write access")

        elif (action == 'Proces-terminate-attempt'):
            if target not in tree.processes[actor].children:
                logger.debug(f"Process {actor} requesting non-child process {target} terminate access")
                event = Event(TYPE_TERM_OTHER)
                tree.add_event(event)
                if tree.search_event(event, 20) > 0.4:
                    logger.debug(f"Excessive termination request detected.")


        elif (action == 'Proces-suspent-resume-accessattempt'):
            if target not in tree.processes[actor].children:
                logger.debug(f"Process {actor} requesting non-child process {target} thread access")

        elif (action == 'Proce-smemory-write-delete-access-attempt'):
            if target not in tree.processes[actor].children:
                logger.debug(f"Process {actor} requesting non-child process {target} all access")

        else:
            return
