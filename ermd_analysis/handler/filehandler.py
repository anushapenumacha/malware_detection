#!/usr/bin/env python

from ermd_analysis.file_obj import File_Obj
from ermd_analysis.utils import *
from ermd_analysis.event import *
from ermd_analysis.process import *
from ermd_analysis.handler import EventHandler
from loguru import logger

class FileHandler(EventHandler):
    def __init__(self):
        pass

    def handle(self, fields, tree):
        irp = fields[0]
        pid = int(fields[1])

        if pid not in tree.get_processes():
            return

        if irp == 'IRP_MJ_CREATE':
            self.handle_create(fields, tree)

        elif irp == 'IRP_MJ_SET_INFORMATION':
            self.handle_set_info(fields, tree)

        elif irp == 'IRP_MJ_WRITE':
            self.handle_write(fields, tree)

        elif irp == 'IRP_MJ_READ':
            self.handle_read(fields, tree)

        else:
            return

    def handle_create(self, fields, tree):
        irp         = fields[0]
        pid         = int(fields[1])
        filename    = strip_hdr(fields[2])
        disposition = fields[3]

        if (disposition in 
            (
                'FILE_CREATE',
                'FILE_SUPERSEDE',
                'FILE_OPEN_IF',
                'FILE_OVERWRITE_IF'
            )
        ):
            tree.add_file_created(filename, File_Obj(filename=filename, pid=pid))

        if (disposition in
            (
                'FILE_SUPERSEDE',
                'FILE_OVERWRITE',
                'FILE_OVERWRITE_IF'
            )
        ):
            tree.add_file_written(filename, File_Obj(filename=filename, pid=pid))

        if (disposition == 'FILE_OPEN_IF'):
            tree.add_file_read(filename, None)

    def handle_set_info(self, fields, tree):
        irp         = fields[0]
        pid         = int(fields[1])
        filename    = strip_hdr(fields[2])
        disposition = fields[3]

        if disposition is 'deletepending':
            tree.add_file_deleted(filename, File_Obj(filename=filename, pid=pid))

    def handle_write(self, fields, tree):
        irp         = fields[0]
        pid         = int(fields[1])
        src_addr    = fields[2]
        dst_file    = strip_hdr(fields[3])
        directory   = '\\'.join(dst_file.split('\\')[0:-1])

        tree.add_file_written(dst_file, File_Obj(filename=dst_file, pid=pid))
        cur_proc = tree.processes[pid]
        if src_addr in cur_proc.memory_map:
            if cur_proc.memory_map[src_addr] == cur_proc.get_sourceimage():
                logger.info(f"Self Replication detected in PID {pid}!"
                    f" ({cur_proc.get_sourceimage()})")

                # Mark file as self replicated
                if dst_file in tree.file_created:
                    tree.file_created[dst_file].self_rep = True

        if directory not in tree.file_directory:
            tree.file_directory.append(directory)

    def handle_read(self, fields, tree):
        irp         = fields[0]
        pid         = int(fields[1])
        dst_addr    = fields[2]
        src_file    = strip_hdr(fields[3])

        if src_file == tree.processes[tree.root_pid].source_image:
            logger.debug(f"Detected loading of original image. Could be self replication.")

        tree.add_file_read(src_file, None)
        tree.processes[pid].add_memory_map(src_file, dst_addr)
